<!DOCTYPE html>
<html>
  <head>
    <title> PPOL670 | Introduction to Data Science for Public Policy   Week 2       Introduction to Programming in R</title>
    <meta charset="utf-8">
    <meta name="author" content="  Prof. Eric Dunford  ◆  Georgetown University  ◆  McCourt School of Public Policy  ◆  eric.dunford@georgetown.edu" />
    <link rel="stylesheet" href="gu-theme.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# <font class = "title-panel"> PPOL670 | Introduction to Data Science for Public Policy </font> <font size=6, face="bold"> Week 2 </font> <br> <br> <font size=200, face="bold"> Introduction to Programming in <code>R</code> </font>
### <font class = "title-footer">  Prof. Eric Dunford  ◆  Georgetown University  ◆  McCourt School of Public Policy  ◆  <a href="eric.dunford@georgetown.edu">eric.dunford@georgetown.edu</a></font>

---




layout: true

&lt;div class="slide-footer"&gt;&lt;span&gt; 
PPOL670 | Introduction to Data Science for Public Policy

&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;

Week 2 &lt;!-- Week of the Footer Here --&gt;

&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;

Introduction to R &lt;!-- Title of the lecture here --&gt;

&lt;/span&gt;&lt;/div&gt; 

---
class: outline

# Outline for Today 

&lt;br&gt; 

- **Interacting** with `R` and `RStudio`

- **Objects** &amp; **Functions**

- **Data Structures** and **accessing** data points

- **Importing/Exporting** data &amp; setting the **working directory**

- Mathematical &amp; Logical **Operators**


---

class: newsection

# Interacting with `R`

---

# R in a Nut Shell

`R` is a statistical and graphical programming language that is based off a much older language called `S`. It's source code is written in C, Fortran, and R. And it's completely **free** under a [GNU General Public License](https://en.wikipedia.org/wiki/GNU_General_Public_License0).

--

### What this means for us:
- **No Barriers to Entry** &amp;rarr; easy to acquire, easy to contribute

- **Active Community** &amp;rarr; if you can think it, there is likely a package out there that does it.

- **Powerful and Adaptive** &amp;rarr; build an estimator from scratch, scrape a web-site, automate the coding of a dataset. All is within one's reach.

---

# Why use R?

`R` offers a powerful way to

- **analyze** data
- **clean** excel spreadsheets (and any other data format) systematically
- **migrate** projects** across platforms
- format and **clean** text
- **manage** _any_ data source
- produce compelling **graphics** and maps

---

# R Studio

**R Studio** is a graphical user interface (GUI) for the R programming language. The software makes `R` more user-friendly adding some point-and-click functionality along with a complete integration of graphs, the data environment, and the coding script.

--

Think of it like this..
&gt; `R` is the engine that runs all our commands, and R Studio is the leather seats and steering wheel. One does the work, the other eases how that work is done.

---

# Installing R and R Studio

To install **R**, download R from CRAN via the following:

- Windows: https://cran.r-project.org/bin/windows/base/
- Mac: https://cran.r-project.org/bin/macosx/

To install **R Studio**, download from the following:

- https://www.rstudio.com/products/rstudio/download/

Useful **video tutorials**:

- [Nathan's (TA) walkthrough](https://www.dropbox.com/s/7af77pyb1wh224w/R-startup.mp4?dl=0)
- Rstudio's Walkthrough:
  + [Install R](https://player.vimeo.com/video/203516510)
  + [Install RStudio](https://player.vimeo.com/video/203516968)

---

### Getting Familiar with R Studio

R Studio is broken up into **4 quandrants** that can be  arranged and customized to the users preference.

.center[&lt;img src="Figures/rstudio.png", width=600&gt;]

---

### Getting Familiar with R Studio

.center[&lt;img src="Figures/rstudio_1_4.png", width=700&gt;]

---

### Getting Familiar with R Studio

.center[&lt;img src="Figures/rstudio_2_4.png", width=700&gt;]

---

### Getting Familiar with R Studio

.center[&lt;img src="Figures/rstudio_3_4.png", width=700&gt;]

---

### Getting Familiar with R Studio

.center[&lt;img src="Figures/rstudio_4_4.png", width=700&gt;]

---

# The Console

The console is where all the action happens. This is "`R`".

.center[&lt;img src="Figures/console.png"&gt;]

---

# The Console

All commands are processed through the console directly (that is, one can type commands directly into it) or via a **script**.

.center[&lt;img src="Figures/console_with_calc.png"&gt;]

---

# Scripts

A script is a `.R` text file where we write and run code our code.

.center[&lt;img src="Figures/empty_script.png"&gt;]

---

# Scripts

When we write a line of code, we can run it in the console by highlighting the text and...
- clicking **`run`**
- pressing **`command + enter`** (mac)
- pressing **`control + enter`** (windows)

.left[&lt;img src="Figures/script_run.png", width=800&gt;]

---

# Scripts

Everything in a script will be treated as **code** -- that is if you run it, the line will be processed through the console.

However, we can leave comments and notes to ourselves by **commenting out** sections of the script using a **`#`**

.left[&lt;img src="Figures/commenting_out.png", width=800&gt;]

---

# R Notebooks


.left[&lt;img src="Figures/rmarkdown-1.png", width=800&gt;]

---

# R Notebooks


.left[&lt;img src="Figures/rmarkdown-2.png", width=800&gt;]

---

# R Notebooks


.left[&lt;img src="Figures/rmarkdown-3.png", width=800&gt;]

---

# R Notebooks


.left[&lt;img src="Figures/rmarkdown-4.png", width=800&gt;]

---

# R Notebooks


.left[&lt;img src="Figures/rmarkdown-5.png", width=800&gt;]

---

# Code Chunks 

`R` notebooks is a great way to seamlessly combine code and prose.

**To write code**, we need to create a **code chunk**. We can do this by: 

- click `insert`, and selec an `R` code chunk. 
- press `cmd` + `option/alt` + `i` or `ctrl` + `option/alt` + `i`

This will yield a discolored chunk that looks like this. Everything written in this chunk will be evaluated as `R` code. Everything written outside of it will be evaluated as prose. Simple enough!


---

class: newsection

# Objects

---

# Objects

R uses a specific set of rules to govern how it looks up values in the environment.

We manage data by assigning it a name, and referencing that name when we need to use the information again.

Officially, this is called `lexical scoping`, which comes from the computer science term "[lexing](https://en.wikipedia.org/wiki/Lexical_analysis)". Lexing is the process by which text represents meaningful pieces of information that the programming language understands.

---

# Assigning an Object

In simple terms, an `object` is a bit of text that represents a specific value.

```r
x &lt;- 3
x
```

```
## [1] 3
```

Here we've assigned the value `3` to the letter `x`. Whenever we type `x`, `R` understands that we really mean `3`.

---

# Assigning an Object

There are three standard assignment operators:
- `&lt;-`
- `=`
- `assign()`

"Best practice" is to use the `&lt;-` assignment operator.

```r
x1 &lt;- 3
x2 = 3
assign("x3",3)
c(x1, x2, x3)
```

```
## [1] 3 3 3
```

---

# Assigning an Object

Note that lexical scoping is flexible. Objects can be written and re-written when necessary.

```r
object &lt;- 5
object
```

```
## [1] 5
```

```r
object &lt;- "A Very Vibrant Shade of Purple"
object
```

```
## [1] "A Very Vibrant Shade of Purple"
```

&lt;br&gt;

&gt; Down the road it will help to give objects &lt;u&gt;meaningful names&lt;/u&gt;!

---

# Objects

One can see all the objects in the environment by either looking at the user interface in RStudio (specifically, the **environment tab**)...

.center[&lt;img src="Figures/environment.png"&gt;]

---

# Objects

One can see all the objects in the environment by either looking at the user interface in RStudio (specifically, the **environment tab**)... or by typing `ls()` in the console.


```r
ls()
```

```
## [1] "object" "x"      "x1"     "x2"     "x3"
```

---

# Object Classes


Once assigned, an object has a **class**. A class describes the properties of the **data type** or **data structure** assigned to an object.

We can use the function `class()` to find out what kind of data type or structure our object is.

```r
class(x) 
```

```
## [1] "numeric"
```

The object `x` is of class `numeric`, i.e. a number.

---

# Object Classes

There are [many classes](https://www.tutorialspoint.com/r/r_data_types.htm) that an object can take.


```r
obj1 &lt;- "This is a sentence"
obj2 &lt;- TRUE
obj3 &lt;- factor("This is a sentence")
c(class(obj1),class(obj2),class(obj3))
```

```
## [1] "character" "logical"   "factor"
```
&lt;br&gt;
&lt;br&gt;

--

&gt; Understanding what class of object one is dealing with is important --- as it will determine what kind of manipulations one can do or what functions an object will work with.

---

# Object Classes

As noted, there are many different **data types** in `R`. We will primarily run into the following types:
&lt;br&gt;
&lt;br&gt;
.center[
| Type | Example|
|---|---|
| Integer | `7` |
| Numeric/Double | `4.56` |
| Character | "Hello!" |
| Logical | `TRUE` |
| Factor | `"cat" (1)` |
]

---

# Object Coercion

When need be, an object can be **coerced** to be a different class.

```r
x
```

```
## [1] 3
```

```r
as.character(x)
```

```
## [1] "3"
```
Here we transformed `x` -- which was an object containing the value `3` --  into a character. `x` is now a string with the text "3".

---

# Removing objects from the Environment

We often want to get rid of objects after creating them. To **delete** (or drop) an object from the working directory, use the function `rm()` -- which stands for "remove".

```r
ls()
```

```
## [1] "obj1"   "obj2"   "obj3"   "object" "x"      "x1"     "x2"     "x3"
```

```r
rm(x,x1,x2,x3,X)
ls()
```

```
## [1] "obj1"   "obj2"   "obj3"   "object"
```

---

# Clearing the Environment

We can also remove **&lt;u&gt;_all_&lt;/u&gt;** objects from the environment at once by typing the following command.


```r
rm(list=ls(all=T))
```

Or we can do so from R Studio by clicking on the `broom icon`.

.center[&lt;img src="Figures/clearing_envir.png", width=500&gt;]

---

# Objects: So what's the point?


**Objects** offer a way to **reference different data**. This means that we can play around with _a lot_ of different data type simultaneously.

This makes it easier to:

--
  + **manage** and use multiple datasets at the same time
  + **extract** and manipulate single variables
  + **work** with little bits of data at a time to make sure your calculations work.

--
&gt; Note that the only way to &lt;u&gt;hold onto information&lt;/u&gt; is to assign it as an object! Else the information is printed but instantly forgotten by `R`

---

class:newsection

# Data Structures

---

## Data Structures

There are also many ways data can be **organized** in `R`.

The same object can be organized in different ways depending on the needs to the user. Some commonly used data structures include:

- `vector`
- `matrix`
- `data.frame`
- `list`
- `array`

---

# Vector


```r
X &lt;- c(1, 2, 4, 5, 44, 6, 10)
X
```

```
## [1]  1  2  4  5 44  6 10
```

```r
class(X)
```

```
## [1] "numeric"
```

```r
length(X)
```

```
## [1] 7
```

---

# Data Frame


```r
data.frame(X)
```

```
##    X
## 1  1
## 2  2
## 3  4
## 4  5
## 5 44
## 6  6
## 7 10
```

---

# Matrix


```r
matrix(X)
```

```
##      [,1]
## [1,]    1
## [2,]    2
## [3,]    4
## [4,]    5
## [5,]   44
## [6,]    6
## [7,]   10
```

---

# List


```r
list(X)
```

```
## [[1]]
## [1]  1  2  4  5 44  6 10
```

---

# Array


```r
array(X,dim = c(2,2,2))
```

```
## , , 1
## 
##      [,1] [,2]
## [1,]    1    4
## [2,]    2    5
## 
## , , 2
## 
##      [,1] [,2]
## [1,]   44   10
## [2,]    6    1
```

---

# The point...


&gt; We need to understand the **_structure_** of a data object to understand how to **_access_** the information inside.

- **Many ways to organize the same piece of information `R`**
  + different data structures afford us different advantages and bring with them different limitations.

- As you become more acquainted with `R`, you'll see and use other types of data structures more often.

- We'll rely mainly on a special type of `data.frame` called a `tibble` data frame. (More on this next time!)


---

class:newsection

# Accessing Relational Data in a Data Frame

---

## Accessing a `data.frame` Object

One must understand the **structure of an object** in order to systematically access the material contained within it.

--

Let's use a dataset inherent to `R` called `cars`. There are a number of datasets that are built into `R`. These are for demonstration purposes.

Note that these data will not appear in the environment &lt;u&gt;**until we assign them to an object**&lt;/u&gt;.


```r
data &lt;- cars
class(data)
```

```
## [1] "data.frame"
```

---

## `data.frame`: relational structure

An easy way to see what's inside a data object is to just `print()` it. `R` prints objects automatically in the console.

```r
data
```

```
##    speed dist
## 1      4    2
## 2      4   10
## 3      7    4
## 4      7   22
## 5      8   16
## 6      9   10
## 7     10   18
## 8     10   26
## 9     10   34
## 10    11   17
## 11    11   28
## 12    12   14
## 13    12   20
## 14    12   24
## 15    12   28
## 16    13   26
## 17    13   34
## 18    13   34
## 19    13   46
## 20    14   26
## 21    14   36
## 22    14   60
## 23    14   80
## 24    15   20
## 25    15   26
## 26    15   54
## 27    16   32
## 28    16   40
## 29    17   32
## 30    17   40
## 31    17   50
## 32    18   42
## 33    18   56
## 34    18   76
## 35    18   84
## 36    19   36
## 37    19   46
## 38    19   68
## 39    20   32
## 40    20   48
## 41    20   52
## 42    20   56
## 43    20   64
## 44    22   66
## 45    23   54
## 46    24   70
## 47    24   92
## 48    24   93
## 49    24  120
## 50    25   85
```


---

## `data.frame`: relational structure

We can look at the **structure** of a data object by using the `str()` function.

```r
str(data)
```

```
## 'data.frame':	50 obs. of  2 variables:
##  $ speed: num  4 4 7 7 8 9 10 10 10 11 ...
##  $ dist : num  2 10 4 22 16 10 18 26 34 17 ...
```

Or grad that variable names using the `colnames()` function.

```r
colnames(data)
```

```
## [1] "speed" "dist"
```

---

## Accessing data in a `data.frame` 

We can leverage what we know about the dimensionality of the data to extract parts of it.

We do this by using brackets `[]` alongside the data object. We then can access the **dimensions** in the data by specifying the row and column

&lt;br&gt;&lt;br&gt;&lt;br&gt;
`data[`&lt;font color = 'red'&gt;`row`&lt;/font&gt;`,`&lt;font color = 'blue'&gt;`column`&lt;/font&gt;`]`

---

&lt;img src="lecture-week-02_intro-to-R_files/figure-html/unnamed-chunk-19-1.png" style="display: block; margin: auto;" /&gt;

---

&lt;img src="lecture-week-02_intro-to-R_files/figure-html/unnamed-chunk-20-1.png" style="display: block; margin: auto;" /&gt;

---

&lt;img src="lecture-week-02_intro-to-R_files/figure-html/unnamed-chunk-21-1.png" style="display: block; margin: auto;" /&gt;

---

&lt;img src="lecture-week-02_intro-to-R_files/figure-html/unnamed-chunk-22-1.png" style="display: block; margin: auto;" /&gt;

---

&lt;img src="lecture-week-02_intro-to-R_files/figure-html/unnamed-chunk-23-1.png" style="display: block; margin: auto;" /&gt;

---

&lt;img src="lecture-week-02_intro-to-R_files/figure-html/unnamed-chunk-24-1.png" style="display: block; margin: auto;" /&gt;
    
---


&lt;img src="lecture-week-02_intro-to-R_files/figure-html/unnamed-chunk-25-1.png" style="display: block; margin: auto;" /&gt;


---

&lt;img src="lecture-week-02_intro-to-R_files/figure-html/unnamed-chunk-26-1.png" style="display: block; margin: auto;" /&gt;

---

&lt;img src="lecture-week-02_intro-to-R_files/figure-html/unnamed-chunk-27-1.png" style="display: block; margin: auto;" /&gt;

---

## Dimensions

The function `dim()` can tell use about the dimensions of a data object.


```r
dim(data)
```

```
## [1] 50  2
```

We now know that the object `data` has **50 rows** and **2 columns**.

---

## Accessing relational data 


```r
data[,2] # Access the entire 2nd column
```

```
##  [1]   2  10   4  22  16  10  18  26  34  17  28  14  20  24  28  26  34
## [18]  34  46  26  36  60  80  20  26  54  32  40  32  40  50  42  56  76
## [35]  84  36  46  68  32  48  52  56  64  66  54  70  92  93 120  85
```

```r
data[49,] # Access just the 49th row
```

```
##    speed dist
## 49    24  120
```


---

## Accessing relational data 


```r
data[1,2] # Access just a cell
```

```
## [1] 2
```

--


```r
data[2:3,1:2] # partial subset
```

```
##   speed dist
## 2     4   10
## 3     7    4
```

--

The key is to keep in mind the dimensions. We can't access data that isn't there.


```r
data[51,]
```

```
##    speed dist
## NA    NA   NA
```

---

## Accessing variables 

Most data objects can be accessed using `$` call sign.

`$` acts as a **key** by which we can extract a specific variable or data feature.

If we hit **Tab** after specifying the `$` after our data object, R Studio will offer a list of all available variables.

.center[&lt;img src="Figures/sign_in.png" align="middle"&gt;]

---

## Accessing variables 

Here we call the `speed` variable from our dataset.

```r
data$speed
```

```
##  [1]  4  4  7  7  8  9 10 10 10 11 11 12 12 12 12 13 13 13 13 14 14 14 14
## [24] 15 15 15 16 16 17 17 17 18 18 18 18 19 19 19 20 20 20 20 20 22 23 24
## [47] 24 24 24 25
```


---

There are many functions designed to help us understand the **dimensions** of a data structure.

```r
dim(data) # Dimensions
```

```
## [1] 50  2
```

```r
nrow(data) # Number of Rows
```

```
## [1] 50
```

```r
ncol(data) # Number of Columns
```

```
## [1] 2
```


---

There are also some useful functions built into R to view portions of a data structure.


```r
head(data,3) # Reports the 3 first entries
```

```
##   speed dist
## 1     4    2
## 2     4   10
## 3     7    4
```

```r
tail(data,3) # Reports the 3 last entries
```

```
##    speed dist
## 48    24   93
## 49    24  120
## 50    25   85
```

---

`summary()` allows for one to quickly summarize the distributions across a set of variables

```r
summary(data)
```

```
##      speed           dist       
##  Min.   : 4.0   Min.   :  2.00  
##  1st Qu.:12.0   1st Qu.: 26.00  
##  Median :15.0   Median : 36.00  
##  Mean   :15.4   Mean   : 42.98  
##  3rd Qu.:19.0   3rd Qu.: 56.00  
##  Max.   :25.0   Max.   :120.00
```

---

class:newsection

# Operators

---


## Mathematical Operators

Broadly speaking, `R` functions as general calculator that can process a variety of data types.

As we can see, most operators in `R` are the usual suspects, but some forms are particular to `R`.

.center[
| Operation       |      Calc      |     Out |
|-----------------|-----------------|-----------------|
|Addition     |         `3 + 4`     |      `7`|
|Subtraction  |          `3 - 4`    |       `-1`|
|Multiplication    |    `3 * 4`       |    `12`|
|Division           |   `3 / 4`     |     `.75`|
|Exponentiation     |   `3 ^ 4`      |     `81`|
|Modulo     |  `4%%3`     |     `1`|
]

In the example, we'll walk through a few more operators.

---

# Mathematical Functions

There are a range of functions designed to ease mathematical calculations. Some of these functions are to calculate specific values, such as the **natural log** or **Euler's number** ($e^a$).


```r
log(4)
```

```
## [1] 1.386294
```

```r
exp(5)
```

```
## [1] 148.4132
```

---

There are a range of functions designed to ease mathematical calculations. Others can be used to find the **sum** for a numerical vector, the **mean**, or the **median**


```r
x &lt;-  c(1,3,7,100)
sum(x)
```

```
## [1] 111
```

```r
mean(x)
```

```
## [1] 27.75
```

```r
median(x)
```

```
## [1] 5
```

---

# Logical Operators

Boolean statement (i.e. true/false statements) are central to any computer programming environment. Boolean statements allow us to make quick conditional evaluations, which are key to **subsetting** data.

--

The following outlines the various types of boolean statements available.


```r
x == y      # equals to
x != y      # does not equal
x &gt;= y      # greater than or equal to
x &lt;= y      # less than or equal to
x &gt; y       # greater than
x &lt; y       # less than
```


--

Statements can be combined using **and** (`&amp;`) **or** (`|`) statements to make more specific queries.

```r
x==1 &amp; y==5 # "and" conditional statements
x==1 | y==5 # "or" conditional statements
```


---

Boolean statements can be fed directly into data objects via the brackets method `[]`. This offers a powerful and simple way to subset data.


```r
x &lt;-  c(1,33,100,.6,5,77)
x
```

```
## [1]   1.0  33.0 100.0   0.6   5.0  77.0
```

```r
x[x &gt; 30]
```

```
## [1]  33 100  77
```

---

There are also a number of base functions that provide useful boolean evaluations. Here are just a few examples...


```r
is.character("hello") # for class
```

```
## [1] TRUE
```

```r
all(c(T,F,F)) # are all entries True?
```

```
## [1] FALSE
```

```r
identical(1+1,2) # are these entries the same?
```

```
## [1] TRUE
```

---

Finally, boolean statements have a nice property in `R`. If we convert a boolean statement to a **numeric class**, `TRUE` values convert to `1` and `FALSE` values convert to `0`.

This offers us a quick way of generating **dichotomous** values.


```r
x &lt;- 1:10
x &gt;= 5
```

```
##  [1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE
```

```r
as.numeric(x &gt;= 5)
```

```
##  [1] 0 0 0 0 1 1 1 1 1 1
```

---

## Subsetting with logical operators

We can combine what we know about logical and accessing the columns and rows in a relational `data.frame` to a powerful effect. 

--


```r
d &lt;- data.frame(x = c(100,200,300,400),
                y = c("a","b","b","a"))
d
```

```
##     x y
## 1 100 a
## 2 200 b
## 3 300 b
## 4 400 a
```

--


```r
d[ d$x &gt; 2, ]
```

```
##     x y
## 1 100 a
## 2 200 b
## 3 300 b
## 4 400 a
```

---

# Tutorial

&lt;br&gt;
&lt;br&gt;
.center[**Try for yourself!**]
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
The following link will take you to an interactive notebook where you can try out some of the concepts we just discussed in class
&lt;br&gt;
&lt;br&gt;
&lt;br&gt;
.center[**[Objects, Data Structures, and Operators](https://dunforde.shinyapps.io/week02-interactive-practice-01/)**]



---

class: newsection

# Functions

---

# What are functions?

&lt;br&gt; 

A **function** is a type of object in `R` that can perform a specific task. Unlike objects that hold data, functions take **arguments** and return the output of some manipulation.

--

A function is specified first with the object name and then parentheses. For example, the function `log()` calculates the natural log of any number placed inside the parentheses.

```r
log(4)
```

```
## [1] 1.386294
```

---

# Where are functions exactly?

Functions operate in the **background**.

There are a number of functions in `R`, known as **base functions**, that are always running when you turn `R` on.

When we need to do things that are &lt;u&gt;**not**&lt;/u&gt; a part of the base functionality, we can import new functions by installing **packages**. But more on this later.

---

# Some common functions

We've already come a across a few functions, and we'll learn a lot more moving forward. Just keep in mind that whenever something is wrapped in parentheses `()`, it's a function.

Here are examples of a few common base functions that we'll see.

.center[
| Function | Description |
| :---: | :---: |
| `c()` | links entries together as a vector |
| `as.character()` | coerces the input to be a character class |
| `length()` | reports how "long" a vector or data frame is |
| `dim()` | reports the dimensions of a data frame |
| `class()` | reports the class of an object |
]

---

## Figuring out what a function does...

All functions in `R` contain rich documentation regarding how a function works, the inputs it requires, and example code. We can access this documentation by using `?` in front of the function.

```r
?c()
```

&lt;img src="Figures/function_help.png", align="middle"&gt;

---

class:newsection

# Packages

---

## R Packages

There are a number of `packages` that are supplied with the R distribution. These are known as "[base packages](https://stat.ethz.ch/R-manual/R-devel/library/base/html/00Index.html)" and they are in the background the second one starts a session in R.

--

- A **`package`** is a set of functions and programs that perform specific tasks. 

- By installing packages, **we introduce new forms of functionality to the R environment**.

---

## R Packages

To use the content in a package, one first needs to **install it**. One can do this by utilizing the following function: `install.packages()`. By inserting the name of a specific package, we can connect to an R "mirror" and download the binary of the package.


```r
install.packages("tidyverse")
```

The version of that package is then saved on your computer and can be called at any time (on or offline).

---

## R Packages

Once installed, it's on the system for good. You can then reference or load the package any time you wish to use a function from it.

There are two functions we can use to load a package: `library()` and `require()`.


```r
library(tidyverse)

# or

require(tidyverse)
```

&gt; You must &lt;u&gt;load&lt;/u&gt; the package before you can use any function in it.

---

`R Studio` also offers us a way to install packages through the interface.

If we click on the `Packages` tab and then click `Install`, we can download a package by typing its name.

&lt;img src="Figures/install_packages.png"&gt;

---

We then can **load** the package from R Studio by clicking the check box beside the packages name.

&lt;img src="Figures/load_package.png"&gt;

---

Sometimes one has _a lot_ of packages running simultaneously.

No problem: we can see what packages are up and running by typign `sessionInfo()` into the console.

This will tell us everything about the version of R and the packages we are using to run our analysis.

```r
sessionInfo()
```

```
## R version 3.5.1 (2018-07-02)
## Platform: x86_64-apple-darwin15.6.0 (64-bit)
## Running under: macOS  10.14
## 
## Matrix products: default
## BLAS: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRblas.0.dylib
## LAPACK: /Library/Frameworks/R.framework/Versions/3.5/Resources/lib/libRlapack.dylib
## 
## locale:
## [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8
## 
## attached base packages:
## [1] stats     graphics  grDevices utils     datasets  methods   base     
## 
## other attached packages:
##  [1] shiny_1.2.0     bindrcpp_0.2.2  forcats_0.3.0   stringr_1.3.1  
##  [5] dplyr_0.7.8     purrr_0.2.5     readr_1.1.1     tidyr_0.8.2    
##  [9] tibble_2.0.1    ggplot2_3.1.0   tidyverse_1.2.1
## 
## loaded via a namespace (and not attached):
##  [1] tidyselect_0.2.5 xfun_0.4         haven_1.1.2      lattice_0.20-35 
##  [5] colorspace_1.3-2 htmltools_0.3.6  yaml_2.2.0       rlang_0.3.1     
##  [9] pillar_1.3.1     later_0.7.3      glue_1.3.0       withr_2.1.2     
## [13] modelr_0.1.2     readxl_1.1.0     bindr_0.1.1      plyr_1.8.4      
## [17] munsell_0.5.0    gtable_0.2.0     cellranger_1.1.0 rvest_0.3.2     
## [21] codetools_0.2-15 evaluate_0.12    knitr_1.21       httpuv_1.4.5    
## [25] broom_0.5.0      Rcpp_1.0.0       xtable_1.8-2     promises_1.0.1  
## [29] scales_1.0.0     backports_1.1.3  jsonlite_1.5     mime_0.6        
## [33] hms_0.4.2        digest_0.6.18    stringi_1.2.4    xaringan_0.8    
## [37] grid_3.5.1       rprojroot_1.3-2  cli_1.0.1        tools_3.5.1     
## [41] magrittr_1.5     lazyeval_0.2.1   crayon_1.3.4     pkgconfig_2.0.2 
## [45] xml2_1.2.0       lubridate_1.7.4  assertthat_0.2.0 rmarkdown_1.10  
## [49] httr_1.3.1       rstudioapi_0.9.0 R6_2.3.0         nlme_3.1-137    
## [53] compiler_3.5.1
```

---

## Remember to Load Your Package!

If you ever try to run a function and you get the following prompt...

    Error: could not find function "qplot"

It's likely you forgot to &lt;font size=10 color="blue", style="bold"&gt; &lt;u&gt;load the package&lt;/u&gt; &lt;/font&gt;.

```r
require(ggplot2) # First Load the package
qplot() # Then run the function
# Wah-la!
```

---

class:newsection

# Importing &amp; Exporting Data

---


`R` allows you to import a large variety of datasets into the environment. However, `R`'s base packages &lt;u&gt;only support a few data types&lt;/u&gt;.

--

No Fear: there is usually always an **external package** that can do the job!

We are going to focus on **three packages** to import different data types:

- `readr` --- an expansive array of functions to read different data types
- `readxl` --- for excel spreadsheets
- `haven` --- for SPSS, SAS, and .dta

---


First, we need to **install** these packages onto our computer.

```r
install.packages("readr")
install.packages("readxl")
install.packages("haven")
```

And then **load** them into our current `R` Session.

```r
require(readr)
require(readxl)
require(haven)
```

---

# Importing data

Here we will review how to import five separate data types:
- `.dta` --- STATA file format
- `.csv` --- comma seperated file format
- `.sav` --- SPSS file format
- `.xlsx` --- standard Excel file format
- `.Rdata` --- R's file format

---

# .dta

For all versions of STATA

```r
require(haven)
data &lt;- read_dta(file = "data.dta")
```
&lt;br&gt;
Other packages:
- `readstata13`
- `foreign`

---

# .csv

`read.csv()` and `read.table()` are both **base functions** in `R`.

```r
data &lt;- read.csv(file = "data.csv",
                stringsAsFactors = F)
# Or

data &lt;- read.table(file = "data.csv",
                  header = T,
                  sep=",",
                  stringsAsFactors = F)
```

These functions have specific **arguments** that we are referencing:
- `stringsAsFactors` means that we don't want all `character` vectors in the `data.frame` to be converted to `factors`.
- `header` means the first row of the data are column names.
- `sep` means that entries are separated by commas.

---

# .csv

The `readr` package provides a much simpler approach.

```r
require(readr)
data &lt;- read_csv("data.csv")
```
- `characters` aren't converted to `factors`.
- More efficient as `\(N\)` increase

---

#.sav

For `SPSS` and `SAS` file formats, the `haven` packages offers a simple way of reading in data.

```r
require(haven)
data &lt;- read_sav(file = "data.sav") # SPSS
```

---

# .xlsx


```r
require(readxl)
data &lt;- read_excel("data.xlsx")
```

Even select from specific sheets.

```r
excel_sheets("data.xlsx") # list avail. sheets
```
    [1] Sheet1, Sheet2

```r
data &lt;- read_excel("data.xlsx",
                   sheet = 'Sheet1')
```


---

# .Rdata

`.Rdata` is the data source inherent to `R`. It saves and loads `objects`.

```r
load(file='data.Rdata')
```

---

# Importing Data Using R Studio

There is also a point-and-click option for importing and exporting data in R.

If we go into the `Environments` tab and then click `Import Dataset`

&lt;img src="Figures/importing.png"&gt;

---

# Exporting data

Exporting data is the same process in reverse. Instead of **reading** the data, we want to **write** a new version of it.

There are a series of functions (each provided by their respective packages) that allow us to do just that.

Each require that you input the **data** that you're looking to export and specify the **file name** and **paths** to tell the computer where the file is going.

---

# Exporting data


```r
write_dta(data,path ="data.dta")

write_csv(data,path ="data.csv")

write_sav(data,path ="data.sav")

write_sas(data,path ="data.sas")

write_tsv(data,path ="data.tab")

# etc.
```

---

# .Rdata

`.Rdata` offers two options to save data. We can either save a single data object, or save the entire workspace

```r
# Save just an object
save(data, file="data.Rdata")


# Save the entire workspace
save.image(file="workspace.Rdata")
```

---

class: newsection

# But where is my data exactly?


---

# But where is my data exactly?


`R` doesn't intuitively know where your data is. If the data is in a special folder entitled "`my_data`", we have to tell `R` how to get there.

We can do this three ways:

--

  1. Set the **working directory** to that folder
  2. Set the directory via a point-and-click option in `R Studio`
  3. Establish the **path** to that directly to the folder

---

# Setting the Working Directory

Every time `R` boots up, it does so in the same place, unless we tell it to go somewhere else.

We can find out which directory we are in by using the `getwd()` function.

```r
getwd() # Get the current working directory
```
    /Users/edunford/


---

# Setting the Working Directory

Every time `R` boots up, it does so in the same place, unless we tell it to go somewhere else.

We can then set a new working director by establishing the path to the folder we want to work in as a **string** in the function `setwd()`

```r
setwd("/Users/edunford/Desktop/my_data")
getwd()
```
     /Users/edunford/Desktop/my_data/

---

# Setting the WD via R Studio

R Studio also makes setting the working directory really easy.

Click: `Session` &amp;rarr; `Set Working Directory` &amp;rarr; `Choose Directory...`

This will allow you to set the working directly quickly. The downside is that you have to do it **manually every time you return to this project**. By writing a script for everything you do, it is easier to replicate (and for others to replicate) your work.

---

# Establishing the Path

Finally, we can also just point directly to the data by outlining the specific path.

Here we are assigning a sting containing our **path** to the object `path`.

```r
path &lt;- "~/Desktop/my_data/data.csv"
```

We then load the data using that path.

```r
read.csv(path)
```

---

# Beyond Working Directories

Working directories are limiting:

- If files are **moved** or **renamed**, &lt;font color = "red"&gt; a script won't run &lt;/font&gt;.
&lt;br&gt;
&lt;br&gt;
- Analyses cannot be easily transported across computers or users.

---

# Beyond Working Directories


The solutions:

1. **R Projects**

.center[&lt;img src="Figures/rproj-activate.png", width=400px&gt;]

.center[&lt;img src="Figures/rproj-specify.png", width=400px&gt;]

---

# Beyond Working Directories

The solutions:

1. **R Projects**

2. **R Projects** + the package [`here()`](https://github.com/jennybc/here_here)
  - To easily move around the project's subfiles
  - `here()` works like `file.path()`, but where the path root is implicitly set to “the path to the top-level of my current project”.


---

# Practice

- Let's practice importing, manipulating, and exporting data in `R`. Please refer to the practice `.rmd` accompanying these slides.

&lt;br&gt;&lt;br&gt;

# Next Time

- Manipulation of relational data frame using the tidy framework. 
- Readings on CANVAS. 
- Be sure to meet with your team and set up a `Github` repository for your projects. 









&lt;!-- STOP HERE .... This is for the webscraping week... --&gt;




&lt;!-- Cleaning Text --&gt;
&lt;!-- ======================================================= --&gt;
&lt;!-- type: starter-section --&gt;


&lt;!-- Dealing with text --&gt;
&lt;!-- ======================================================= --&gt;
&lt;!-- incremental:true --&gt;

&lt;!-- We often must deal with problematic text data. Sometimes we need to format responses from a survey so that we can use them in some analysis; other times we are just trying to calculate the date. --&gt;

&lt;!-- Most data is often riddled with errors and issues that are costly to resolve. In a sense, this data is  **_dirty_**. We can't run analysis on dirty data. --&gt;

&lt;!-- **Regular expressions** are a special text string for describing a search pattern. We can extract, clean, and manipulate text using these expressions --- which can save one **hours** from needing to manually clean data. --&gt;

&lt;!-- Regular Expressions --&gt;
&lt;!-- ======================================================= --&gt;
&lt;!-- Consider the following string vector... --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- countries &lt;- c("Canada","Russia","New Zealand","New Guinea") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Say, from this vector, we want to identify which entry contains the word "new". The `grep()` function can help us identify a specific pattern, which it will then return the position of the string. --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- grep(pattern = "New", countries) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Here it return position **3** and position **4**, which correspond with the **_position in the vector_**. --&gt;

&lt;!-- grep() --&gt;
&lt;!-- ======================================================= --&gt;
&lt;!-- We can use that position to draw out specific content. --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- position &lt;- grep(pattern = "New", countries) --&gt;
&lt;!-- countries[position] --&gt;
&lt;!-- ``` --&gt;

&lt;!-- This feature can be useful to identify relevant content in variable or body of text. --&gt;

&lt;!-- gsub() --&gt;
&lt;!-- ======================================================= --&gt;
&lt;!-- `gsub()` can help us actually manipulate the content in a string by identifying a pattern and then **_replacing it_** with something new. --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- countries --&gt;
&lt;!-- gsub(pattern = "New",replacement = "Old",countries) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Cases --&gt;
&lt;!-- ======================================================= --&gt;
&lt;!-- We can also manipulate cases with the `tolower()` and `toupper()` functions. --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- string &lt;- "This Is ReAlLY imPORtant." --&gt;
&lt;!-- tolower(string) --&gt;
&lt;!-- toupper(string) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Trimming White Space --&gt;
&lt;!-- ======================================================= --&gt;
&lt;!-- We can also get rid of excessive **spaces** using the `trimws()` function. --&gt;

&lt;!-- ```{r} --&gt;
&lt;!-- sent &lt;- "        This sentence has a ton of white space             " --&gt;
&lt;!-- sent --&gt;
&lt;!-- trimws(sent) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Generic Patterns --&gt;
&lt;!-- ======================================================= --&gt;
&lt;!-- There are generic ways to draw out specific kinds of content from a string: such as **digits** or **punctuation**. There are many different types of regular expressions, and we don't have time to review all of them here, but here are a few useful ones. --&gt;

&lt;!-- - `"\\w"` &amp;rarr;  words --&gt;
&lt;!-- - `"\\d"` &amp;rarr;  digits --&gt;
&lt;!-- - `"\\s"` &amp;rarr;  space character --&gt;
&lt;!-- - `"*"`  &amp;rarr;  fuzzy --&gt;
&lt;!-- - `"+"` &amp;rarr;  More than one --&gt;
&lt;!-- - `"[]"` &amp;rarr;  Match anything inside the brackets --&gt;

&lt;!-- ======================================================= --&gt;
&lt;!-- Here let's remove problems from the following string using `gsub()`. --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- trouble &lt;- "This ::String is a 2Problem; 56" --&gt;
&lt;!-- trouble &lt;- gsub("[::]","",trouble) --&gt;
&lt;!-- trouble --&gt;
&lt;!-- trouble &lt;- gsub("\\d*","",trouble) --&gt;
&lt;!-- trouble --&gt;
&lt;!-- trouble &lt;- gsub("[;]",".",trouble) --&gt;
&lt;!-- trimws(trouble) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- ======================================================= --&gt;
&lt;!-- We can also target all **punctuation** with the `"[[:punct:]]"` regular expression. --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- dirt &lt;- "C^lean%% this $%&amp;*_@string((!" --&gt;
&lt;!-- dirt --&gt;
&lt;!-- gsub("[[:punct:]]","",dirt) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Joining Text --&gt;
&lt;!-- ======================================================= --&gt;
&lt;!-- We can also **join** or **paste** text using `R`. To do so, we'll use the `paste()` function, which takes two arguments: the strings and a specified separator. --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- sent1 &lt;- "It is nice outside." --&gt;
&lt;!-- sent2 &lt;- "I'll go for a walk." --&gt;
&lt;!-- paste(sent1,sent2,sep = " ") --&gt;
&lt;!-- paste(sent1,sent2,sep = "::::") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Collapsing --&gt;
&lt;!-- ======================================================= --&gt;
&lt;!-- We can also use `paste()` to **collapse** a string vectors down into a single line. We do this by specifying the `collapse=` argument, which is like separate in that it wants to know how the vector should be collapsed. --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- countries --&gt;
&lt;!-- paste(countries,collapse=", ") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- ======================================================= --&gt;
&lt;!-- `collapse=` can be used with `paste()` in useful ways. --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- sent1 &lt;- "These are the countries that matter:" --&gt;

&lt;!-- countries_sent &lt;- paste(countries, --&gt;
&lt;!--                         collapse=", ") --&gt;

&lt;!-- paste(sent1, countries_sent,sep=" ") --&gt;
&lt;!-- ``` --&gt;


&lt;!-- Dates and Time --&gt;
&lt;!-- ======================================================= --&gt;
&lt;!-- `R` has a specific `Date` class. We will use the function `as.Date()` to coerce a relevant string into a date class. --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- str &lt;- "2006-04-30" --&gt;
&lt;!-- class(str) --&gt;
&lt;!-- date_str &lt;- as.Date(str) --&gt;
&lt;!-- class(date_str) --&gt;
&lt;!-- ``` --&gt;

&lt;!-- ======================================================= --&gt;
&lt;!-- Objects of class date have some nice properties, that makes analysis and manipulation easy. --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- date_str --&gt;
&lt;!-- date_str + 30 # date in 30 days --&gt;
&lt;!-- date_str - 3000 # date 300 days ago. --&gt;
&lt;!-- ``` --&gt;

&lt;!-- ======================================================= --&gt;
&lt;!-- This also allows us to look at the distance between two dates. --&gt;
&lt;!-- ```{r,echo=F} --&gt;
&lt;!-- date1 = as.Date("2015-06-07") --&gt;
&lt;!-- date2 = as.Date("2013-02-14") --&gt;
&lt;!-- ``` --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- date1 --&gt;
&lt;!-- date2 --&gt;
&lt;!-- date1-date2 --&gt;
&lt;!-- ``` --&gt;

&lt;!-- Formatting Dates --&gt;
&lt;!-- ======================================================= --&gt;
&lt;!-- That said, dates come in many different formats. To let `R` know that a specific string is a date, we have to tell it the **date format**. --&gt;
&lt;!-- ```{r,eval=F} --&gt;
&lt;!-- example &lt;- "February 3, 1987" --&gt;
&lt;!-- as.Date(example) --&gt;
&lt;!-- ``` --&gt;
&lt;!--       Error in charToDate(x) : --&gt;
&lt;!--       character string is not in a standard unambiguous format --&gt;

&lt;!-- Formatting Dates --&gt;
&lt;!-- ======================================================= --&gt;
&lt;!-- That said, dates come in many different formats. To let `R` know that a specific string is a date, we have to tell it the **date format**. --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- example &lt;- "February 3, 1987" --&gt;
&lt;!-- as.Date(example, format = "%B %d, %Y") --&gt;
&lt;!-- ``` --&gt;

&lt;!-- ======================================================= --&gt;
&lt;!-- **Formatting dates** is similar to regular expressions in that it has a special syntax. In a string (i.e. using " "), we specify the exact pattern of the date with **_all appropriate punctuation and spacing_**. --&gt;

&lt;!-- The following are the main expressions used in formatting. --&gt;

&lt;!-- - `%d` &amp;rarr; day as a number --&gt;
&lt;!-- - `%a` &amp;rarr; abbreviated weekday --&gt;
&lt;!-- - `%A` &amp;rarr; unabbreviated weekday --&gt;
&lt;!-- - `%m` &amp;rarr; month as number --&gt;
&lt;!-- - `%b` &amp;rarr; abbreviated month --&gt;
&lt;!-- - `%B` &amp;rarr; unabbreviated month --&gt;
&lt;!-- - `%y` &amp;rarr; 2 digit year --&gt;
&lt;!-- - `%Y` &amp;rarr; 4 digit year --&gt;

&lt;!-- ======================================================= --&gt;
&lt;!-- ```{r} --&gt;
&lt;!-- as.Date("Friday March 13, 2009","%A %B %d, %Y") --&gt;
&lt;!-- as.Date("11/13/14","%m/%d/%y") --&gt;
&lt;!-- as.Date("7th of May 2000","%dth of %B %Y") --&gt;
&lt;!-- ``` --&gt;


&lt;!-- Applied Example 2 --&gt;
&lt;!-- ======================================================== --&gt;
&lt;!-- type:prompt --&gt;
&lt;!-- Open up an R Studio session and open `operators_and_cleaning_text.R`. --&gt;

&lt;!-- Here we'll review some of the textual manipulations we learned and we'll explore the powerful `stringr` package for text manipulation. --&gt;

&lt;!-- Break --&gt;
&lt;!-- ======================================================= --&gt;
&lt;!-- type:break --&gt;

&lt;!-- When we return, we'll work on building a &lt;font color = 'black', face='bold'&gt; data management &lt;/font&gt; and &lt;font color = 'black',face='bold'&gt; visualization &lt;/font&gt; tool kit. --&gt;
    </textarea>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightStyle": "github",
"countIncrementalSlides": false,
"highlightLines": true
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function() {
  var d = document, s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})();</script>

<script>
(function() {
  var i, text, code, codes = document.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
})();
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
