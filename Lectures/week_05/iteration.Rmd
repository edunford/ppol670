---
title: |
       | PPOL670 | Week 05 
       | Iteration
date: "February 2018"
output: html_document
---

# Indexing Refresher

Recall that we can index data objects in `R`. By taping into each object's structure and using integers to extract data that belong to specific **positions**. 

```{r}
# Example 1
letters
```

The `letters` is a data object that comes preloaded with `R`. In it, we have 26 character values (strings) for each letter of the alphabet. 

We can extract individual values by indexing, using the position to draw out a value. Note that in `R`, we start counting at 1 (verses other languages which start at 0, e.g. python). Thus, `1` will always be the first position in any data object. 

```{r}
letters[1]
```

```{r}
letters[c(5,9,1,2)]
```

Likewise, we can do the same with data frames, except this time we have two position values: `rows` and `columns`. 

Let's use another in-house data object, `mtcars`

```{r}
str(mtcars)
```

We can access specific positions within this data matrix by indexing the rows and/or columns. 
```{r}
mtcars[2,] # Second Row
```

```{r}
mtcars[1:5,1:5] # first five rows and columns
```




# `for` loops

A loop is offers a way to iterate through a series of items stored as data object in `R`. The below loop pulls out each item once at a time, stores it in the object `i` and then prints it. 

```{r}
items <- c("grapes","bananas","chocolate","bread")

for(i in items){
  print(i)
}
```

The above is equivalent to this.

```{r}
i <- items[1]
print(i)
i <- items[2]
print(i)
i <- items[3]
print(i)
i <- items[4]
print(i)
```

As we can see, loops make it far easier to iterate through a repeatitive task. 





## `for` loop components

There are two thing really important features of a loop. 

First, the `for()` function which we use to specify (a) what object we're drawing from and (b) what object we are writing to.

```
  for( i  in  items  )
       ^        ^
       |        |___ object we are drawing from
       |
obj. we write each to item to 
```

Second, the brackets `{}`. Inside the brackets we house the code that is going to happen each iteration. 

```
  for( i  in  items  ){
    |~~~~~~~~~~~~~~~~|   
    |~~~~~~~~~~~~~~~~|
    |~~~~~~~~~~~~~~~~| code we need perform on each iteration.
    |~~~~~~~~~~~~~~~~|
    |~~~~~~~~~~~~~~~~|
  }
```

Together, `for` loops allow us to repeat complicated processes. This prevents us from having to arduously repeat the same chunk of code over and over again. 


```{r}
# example of performing some operation on each iteration.
q <- 0
for(i in 1:10){
  print(q^i) # take q (the previous value of i, the power of the current i)
  q <- i
}
```

Useful? Heck yah!





# `while()` loops

Similar to `for` loops, `while()` loops only stop when some condition is met. The setup is similar to a `for()` loop with respect to the basic set up. In the below example, as long as `i` is less than `10` the loop will keep looping. Put differently, as long as the statement within `while()` is `TRUE`, will the loop keep looping.  

```{r}
i <- 0
while( i < 10 ){
  i <- i + 1
  print(i)
}
```

`while()` loops can be useful when you don't know how long an iteration should go, but that also makes them problematic. They might keep on going (infinitely) even when we don't want them to! So use with caustion.



# Control statements

## `if(){}` & `else{}`

```{r}
if(TRUE){
  print("Hello")
}else{
  print("Goodbye")
}
```

```{r}
if(FALSE){
  print("Hello")
}else{
  print("Goodbye")
}
```

Boolean statement dictates whether one code chunk is executed, or another is executed. We can combine these conditionals with `for()` loops to powerful effect. 

```{r}
for(i in 1:10){
  if(i <= 5){
    print("Hello")
  }else{
    print("Goodbye")
  }
}
```


## `ifelse()`

Same idea just vectorized.

```{r}
ifelse(T,"Hello","Goodbye")
```

```{r}
ifelse(F,"Hello","Goodbye")
```

```{r}
x <- 1:10
ifelse(x<5,"Hello","Goodbye")
```



# `for()` loops and storing output


```{r}
# Container with 10 spaces
container <- rep(0,10)
container
```


```{r}
# Each loop, we store an item
for(i in 1:10){
  container[i] <- letters[i]
}
container
```



```{r}
dat_container <- as.data.frame(matrix(0, nrow = 5,ncol = 2))
dat_container
```


```{r}
for( i in 1:5){
  dat_container[i,1] <- i
  dat_container[i,2] <- letters[i]
}
dat_container
```


# `for()` loops and binding output

Likewise, we can build objects up by binding them together.

```{r}
containter2 <- c()
containter2
```


```{r}
tmp_data <- data.frame(v1=1,v2=2)
tmp_data
```


```{r}
containter2 <- rbind(containter2,tmp_data)
containter2 <- rbind(containter2,tmp_data)
containter2 <- rbind(containter2,tmp_data)
containter2 
```


```{r}
containter2 <- c()
for( i in 1:10){
  
  tmp_data <- data.frame(v1=i,v2=letters[i])
  
  containter2 <- rbind(containter2,tmp_data)
  
}
containter2
```


 
## Which is most efficient?

```{r}
require(tictoc) # for counting how long it takes R to run

N = 5000
tic()
dat_container <- as.data.frame(matrix(0, nrow = N,ncol = 2))
for( i in 1:N){
  dat_container[i,1] <- i
  dat_container[i,2] <- 1/i
}
toc()
```


```{r}
N = 5000
tic()
dat_container <- c()
for( i in 1:N){
  tmp <- data.frame(V1 = i,V2 = 1/i)
  dat_container <- rbind(dat_container,tmp)
}
toc()
```


The first by far! Why would we use the second option? Well, when we're not 100% sure how big our object will be (like when we scrape the web or build up a data object). There are always trade offs!


